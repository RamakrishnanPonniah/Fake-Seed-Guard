<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">

	<!-- jQuery library -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

	<!-- Popper JS -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"></script>

	<!-- Latest compiled JavaScript -->
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>

	<style>
		body {
			font-family: Graphik-Regular;
			overflow: scroll;
			overflow: -moz-scrollbars-none;
			-ms-overflow-style: none;
			font-family: Open Sans, sans-serif;
			background: none;
		}
		label{
            font-weight: bold;
            color:white;
		}
		body::-webkit-scrollbar{
			display: none;
		}
		main {
			margin-top: 6%;
			margin-bottom: 5%;
			height: 100%;
		}

		footer {
			bottom: 0px;
		}

		nav {
			min-height: 10% !important;
			/*background-image:linear-gradient(73deg,#09597f,#20a8e9 48%,#2abaff);*/
			background-image: URL("kx-background.jpg");
			background-position: top;
        }
        .modal-result, .figure-caption{
            color:white;
        }
	</style>

</head>

<body>
	<main class="container-fluid">
		<div class="row" style="min-height:80vh">

			<div class="col-sm-6 modal-body" >
				<form id="myForm" class="container modal-body">

					<input type="file" multiple name="file" id="updImg" class="custom-file-input">
					<label class="custom-file-label" for="customFile">Choose file</label>
				</form>
				<div id="preview">
					<div class="row">
						<div class="col-sm-6">
							<figure class="figure">
								<figcaption class="figure-caption text-center"><strong>Top View</strong></figcaption>
								<img id="ULView" class="rounded img-thumbnail img-fluid figure-img">
							</figure>
						</div>

						<div class="col-sm-6">
							<figure class="figure">
								<figcaption class="figure-caption text-center"><strong>Side View</strong></figcaption>
								<img id="URView" class="rounded img-thumbnail img-fluid figure-img">
							</figure>
						</div>
					</div>

					<div class="row">
						<div class="col-sm-6">
							<figure class="figure">
								<figcaption class="figure-caption text-center"><strong>Lateral View</strong>
								</figcaption>
								<img id="DLView" class="rounded img-thumbnail img-fluid figure-img">
							</figure>
						</div>

						<div class="col-sm-6">
							<figure class="figure">
								<figcaption class="figure-caption text-center"><strong>Lateral View</strong>
								</figcaption>
								<img id="DRView" class="rounded img-thumbnail img-fluid figure-img">
							</figure>
						</div>
					</div>
				</div>
				<div>
					<button id="result" type="submit" style="margin-top: 53px;" class="btn btn-primary btn-lg btn-block" data-toggle="modal"
						data-target="#loadingBar">Generate Result</button>
				</div>

				<div class="modal fade" id="loadingBar" tabindex="-1" role="dialog" aria-labelledby="loadingBarTitle"
					aria-hidden="true">
					<div class="modal-dialog modal-dialog-centered" role="document">
						<div class="modal-content">
							<div class="modal-header">
								<span><strong>
										<h3>Loading</h3>
									</strong></span>
								<div class="spinner-grow text-primary float-left"></div>
								<div class="spinner-grow text-primary float-left"></div>
								<div class="spinner-grow text-primary float-left"></div>
								<div class="spinner-grow text-primary float-left"></div>
								<div class="spinner-grow text-primary float-left"></div>
								<div class="spinner-grow text-primary float-left"></div>
								<div class="spinner-grow text-primary float-left"></div>
								<div class="spinner-grow text-primary float-left"></div>
							</div>
							<div class="modal-body">
								<div class="progress" style="height:30px">
									<div id="progress" class="progress-bar progress-bar-striped progress-bar-animated"
										role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"
										style="width:0%"></div>
								</div>
							</div>

						</div>

					</div>
				</div>
			</div>
			<div class="col-sm-6" >
				<div class="row">

					<div class="mx-auto">
						<div class="modal-header">
							<h4 class="modal-title modal-result">RESULT</h4>
						</div>
						<div class="modal-body">
							<div class="row form-group">
								<div class="col col-sm-6">
									<label for="prediction_decs">Prediction Decision</label>
								</div>
								<div class="col col-sm-6">
									<input id="prediction_decs" type="text" class="form-control" readonly>
								</div>
							</div>

							<div class="row form-group">
								<div class="col col-sm-6">
									<label for="prediction_val">Prediction Score</label>
								</div>
								<div class="col col-sm-6" style="max-height: 90px">
									<!-- <input id="prediction_val" type="text" class="form-control" readonly> -->
									<canvas id="speedometer" width="440" height="220">Canvas not available.</canvas>
								</div>
							</div>
						</div>
						<div>
							<button type="submit" class="btn btn-primary btn-lg btn-block"
								data-toggle="modal" data-target="#report">Report to NSC</button>
						</div>

						<div class="modal fade" id="report" tabindex="-1" role="dialog"
							aria-labelledby="loadingBarTitle" aria-hidden="true">
							<div class="modal-dialog modal-dialog-centered" role="document">
								<div class="modal-content">
									<div class="modal-body">
										<table>
											<tr>
												<td><label style="color:black">Seed Provider Information</label></td>
												<td><textarea rows="4" cols="30"></textarea></td>
											</tr>
											<tr>
												<td><label style="color:black">Date of purchase</label></td>
												<td><input type="date"></td>
											</tr>
											<tr>
												<td><label style="color:black">Seed Quality</label></td>
												<td><select>
														<option>Fake</option>
														<option>Original</option>
														<option>Defective</option>
													</select>
												</td>
											</tr>
											<tr>
												<td>
													<input id="reportSubmit" class="btn btn-primary btn-lg btn-block"
														type="button" data-toggle="modal" data-target="#response" value="Submit">
												</td>
											</tr>
										</table>

									</div>

								</div>
							</div>

						</div>
						<div class="modal fade" id="response" tabindex="-1" role="dialog"
							aria-labelledby="loadingBarTitle" aria-hidden="true">
							<div class="modal-dialog modal-dialog-centered" role="document">
								<div class="modal-content">
									<div class="modal-body">
										Submitted Succesfully to<br/>
										<strong>National Seed Corporation</strong>
									</div>

								</div>
							</div>

						</div>
					</div>

				</div>
	</main>
</body>
<script language="javascript" type="text/javascript">

var iCurrentSpeed = 0,
    iTargetSpeed = 0,
    bDecrement = null,
    job = null;
	draw();
function degToRad(angle) {
    // Degrees to radians
    return ((angle * Math.PI) / 180);
}

function radToDeg(angle) {
    // Radians to degree
    return ((angle * 180) / Math.PI);
}

function drawLine(options, line) {
    // Draw a line using the line object passed in
    options.ctx.beginPath();

    // Set attributes of open
    options.ctx.globalAlpha = line.alpha;
    options.ctx.lineWidth = line.lineWidth;
    options.ctx.fillStyle = line.fillStyle;
    options.ctx.strokeStyle = line.fillStyle;
    options.ctx.moveTo(line.from.X,
        line.from.Y);

    // Plot the line
    options.ctx.lineTo(
        line.to.X,
        line.to.Y
    );

    options.ctx.stroke();
}

function createLine(fromX, fromY, toX, toY, fillStyle, lineWidth, alpha) {
    // Create a line object using Javascript object notation
    return {
        from: {
            X: fromX,
            Y: fromY
        },
        to:    {
            X: toX,
            Y: toY
        },
        fillStyle: fillStyle,
        lineWidth: lineWidth,
        alpha: alpha
    };
}

function drawOuterMetallicArc(options) {
    /* Draw the metallic border of the speedometer
     * Outer grey area
     */
/*    options.ctx.beginPath();

    // Nice shade of grey
    options.ctx.fillStyle = "rgb(127,127,127)";

    // Draw the outer circle
    options.ctx.arc(options.center.X,
        options.center.Y,
        options.radius,
        0,
        Math.PI,
        true);

    // Fill the last object
    options.ctx.fill();
*/
}

function drawInnerMetallicArc(options) {
    /* Draw the metallic border of the speedometer
     * Inner white area
     */

    /*options.ctx.beginPath();

    // White
    options.ctx.fillStyle = "rgb(255,255,255)";

    // Outer circle (subtle edge in the grey)
    options.ctx.arc(options.center.X,
                    options.center.Y,
                    (options.radius / 100) * 90,
                    0,
                    Math.PI,
                    true);

    options.ctx.fill();
    
    */
}

function drawMetallicArc(options) {
    /* Draw the metallic border of the speedometer
     * by drawing two semi-circles, one over lapping
     * the other with a bot of alpha transparency
     */

    drawOuterMetallicArc(options);
    drawInnerMetallicArc(options);
}

function drawBackground(options) {
    /* Black background with alphs transparency to
     * blend the edges of the metallic edge and
     * black background
     */
   var i = 0;

    options.ctx.fillStyle = "rgb(0,0,0)";

    // Draw semi-transparent circles
    for (i = 95; i < 100; i++) {
        options.ctx.beginPath();

        options.ctx.arc(options.center.X,
            options.center.Y,
            i,
            0,
            Math.PI,
            true);

        options.ctx.fill();
    }
    
}

function applyDefaultContextSettings(options) {
    /* Helper function to revert to gauges
     * default settings
     */

    options.ctx.lineWidth = 2;
    options.ctx.strokeStyle = "rgb(255, 255, 255)";
    options.ctx.fillStyle = 'rgb(255,255,255)';
}

function drawSmallTickMarks(options) {
    /* The small tick marks against the coloured
     * arc drawn every 5 mph from 10 degrees to
     * 170 degrees.
     */

    var tickvalue = options.levelRadius - 8,
        iTick = 0,
        gaugeOptions = options.gaugeOptions,
        iTickRad = 0,
        onArchX,
        onArchY,
        innerTickX,
        innerTickY,
        fromX,
        fromY,
        line,
        toX,
        toY;

    applyDefaultContextSettings(options);

    // Tick every 20 degrees (small ticks)
    for (iTick = 10; iTick < 180; iTick += 20) {

        iTickRad = degToRad(iTick);

        /* Calculate the X and Y of both ends of the
         * line I need to draw at angle represented at Tick.
         * The aim is to draw the a line starting on the
         * coloured arc and continueing towards the outer edge
         * in the direction from the center of the gauge.
         */

        onArchX = gaugeOptions.radius - (Math.cos(iTickRad) * tickvalue);
        onArchY = gaugeOptions.radius - (Math.sin(iTickRad) * tickvalue);
        innerTickX = gaugeOptions.radius - (Math.cos(iTickRad) * gaugeOptions.radius);
        innerTickY = gaugeOptions.radius - (Math.sin(iTickRad) * gaugeOptions.radius);

        fromX = (options.center.X - gaugeOptions.radius) + onArchX;
        fromY = (gaugeOptions.center.Y - gaugeOptions.radius) + onArchY;
        toX = (options.center.X - gaugeOptions.radius) + innerTickX;
        toY = (gaugeOptions.center.Y - gaugeOptions.radius) + innerTickY;

        // Create a line expressed in JSON
        line = createLine(fromX, fromY, toX, toY, "rgb(127,127,127)", 3, 1);

        // Draw the line
        drawLine(options, line);

    }
}

function drawLargeTickMarks(options) {
    /* The large tick marks against the coloured
     * arc drawn every 10 mph from 10 degrees to
     * 170 degrees.
     */

    var tickvalue = options.levelRadius - 8,
        iTick = 0,
        gaugeOptions = options.gaugeOptions,
        iTickRad = 0,
        innerTickY,
        innerTickX,
        onArchX,
        onArchY,
        fromX,
        fromY,
        toX,
        toY,
        line;

    applyDefaultContextSettings(options);

    tickvalue = options.levelRadius - 2;

    // 10 units (major ticks)
    for (iTick = 20; iTick < 180; iTick += 20) {

        iTickRad = degToRad(iTick);

        /* Calculate the X and Y of both ends of the
         * line I need to draw at angle represented at Tick.
         * The aim is to draw the a line starting on the
         * coloured arc and continueing towards the outer edge
         * in the direction from the center of the gauge.
         */

        onArchX = gaugeOptions.radius - (Math.cos(iTickRad) * tickvalue);
        onArchY = gaugeOptions.radius - (Math.sin(iTickRad) * tickvalue);
        innerTickX = gaugeOptions.radius - (Math.cos(iTickRad) * gaugeOptions.radius);
        innerTickY = gaugeOptions.radius - (Math.sin(iTickRad) * gaugeOptions.radius);

        fromX = (options.center.X - gaugeOptions.radius) + onArchX;
        fromY = (gaugeOptions.center.Y - gaugeOptions.radius) + onArchY;
        toX = (options.center.X - gaugeOptions.radius) + innerTickX;
        toY = (gaugeOptions.center.Y - gaugeOptions.radius) + innerTickY;

        // Create a line expressed in JSON
        line = createLine(fromX, fromY, toX, toY, "rgb(127,127,127)", 3, 1);

        // Draw the line
        drawLine(options, line);
    }
}

function drawTicks(options) {
    /* Two tick in the coloured arc!
     * Small ticks every 5
     * Large ticks every 10
     */
    drawSmallTickMarks(options);
    drawLargeTickMarks(options);
}

function drawTextMarkers(options) {
    /* The text labels marks above the coloured
     * arc drawn every 10 mph from 10 degrees to
     * 170 degrees.
     */
    var innerTickX = 0,
        innerTickY = 0,
        iTick = 0,
        gaugeOptions = options.gaugeOptions,
        iTickToPrint = 00;

    applyDefaultContextSettings(options);

    // Font styling
    options.ctx.font = 'italic 12px sans-serif';
    options.ctx.textBaseline = 'top';

    options.ctx.beginPath();

    // Tick every 20 (small ticks)
    for (iTick = 10; iTick < 180; iTick += 20) {

        innerTickX = gaugeOptions.radius - (Math.cos(degToRad(iTick)) * gaugeOptions.radius);
        innerTickY = gaugeOptions.radius - (Math.sin(degToRad(iTick)) * gaugeOptions.radius);

        // Some cludging to center the values (TODO: Improve)
        if (iTick <= 10) {
            options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX,
                    (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY + 5);
        } else if (iTick < 50) {
            options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX - 5,
                    (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY + 5);
        } else if (iTick < 90) {
            options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX,
                    (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY);
        } else if (iTick === 90) {
            options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX + 4,
                    (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY);
        } else if (iTick < 145) {
            options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX + 10,
                    (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY);
        } else {
            options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX + 15,
                    (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY + 5);
        }

        // MPH increase by 10 every 20 degrees
        //iTickToPrint += Math.round(2160 / 9);
         iTickToPrint += 10;
    }

    options.ctx.stroke();
}

function drawSpeedometerPart(options, alphaValue, strokeStyle, startPos) {
    /* Draw part of the arc that represents
    * the colour speedometer arc
    */

    options.ctx.beginPath();

    options.ctx.globalAlpha = alphaValue;
    options.ctx.lineWidth = 5;
    options.ctx.strokeStyle = strokeStyle;

    options.ctx.arc(options.center.X,
        options.center.Y,
        options.levelRadius,
        Math.PI + (Math.PI / 360 * startPos),
        0 - (Math.PI / 360 * 10),
        false);

    options.ctx.stroke();
}

function drawSpeedometerColourArc(options) {
    /* Draws the colour arc.  Three different colours
     * used here; thus, same arc drawn 3 times with
     * different colours.
     * TODO: Gradient possible?
     */

    var startOfGreen = 10,
        endOfGreen = 200,
        endOfOrange = 280;

    drawSpeedometerPart(options, 1.0, "white", startOfGreen);
    drawSpeedometerPart(options, 1, "white", endOfGreen);
    drawSpeedometerPart(options, 1, "white", endOfOrange);

}

function drawNeedleDial(options, alphaValue, strokeStyle, fillStyle) {
    /* Draws the metallic dial that covers the base of the
    * needle.
    */
    var i = 0;

    options.ctx.globalAlpha = alphaValue;
    options.ctx.lineWidth = 3;
    options.ctx.strokeStyle = strokeStyle;
    options.ctx.fillStyle = fillStyle;

    // Draw several transparent circles with alpha
    for (i = 0; i < 30; i++) {

        options.ctx.beginPath();
        options.ctx.arc(options.center.X,
            options.center.Y,
            i,
            0,
            Math.PI,
            true);

        options.ctx.fill();
        options.ctx.stroke();
    }
}

function convertSpeedToAngle(options) {
    /* Helper function to convert a speed to the
    * equivelant angle.
    */
    var iSpeed = (options.speed / 10),
        iSpeedAsAngle = ((iSpeed * 20) + 10) % 180;

    // Ensure the angle is within range
    if (iSpeedAsAngle > 180) {
        iSpeedAsAngle = iSpeedAsAngle - 180;
    } else if (iSpeedAsAngle < 0) {
        iSpeedAsAngle = iSpeedAsAngle + 180;
    }

    return iSpeedAsAngle;
}

function drawNeedle(options) {
    /* Draw the needle in a nice read colour at the
    * angle that represents the options.speed value.
    */

    var iSpeedAsAngle = convertSpeedToAngle(options),
        iSpeedAsAngleRad = degToRad(iSpeedAsAngle),
        gaugeOptions = options.gaugeOptions,
        innerTickX = gaugeOptions.radius - (Math.cos(iSpeedAsAngleRad) * 20),
        innerTickY = gaugeOptions.radius - (Math.sin(iSpeedAsAngleRad) * 20),
        fromX = (options.center.X - gaugeOptions.radius) + innerTickX,
        fromY = (gaugeOptions.center.Y - gaugeOptions.radius) + innerTickY,
        endNeedleX = gaugeOptions.radius - (Math.cos(iSpeedAsAngleRad) * gaugeOptions.radius),
        endNeedleY = gaugeOptions.radius - (Math.sin(iSpeedAsAngleRad) * gaugeOptions.radius),
        toX = (options.center.X - gaugeOptions.radius) + endNeedleX,
        toY = (gaugeOptions.center.Y - gaugeOptions.radius) + endNeedleY,
        line = createLine(fromX, fromY, toX, toY, "rgb(127, 127, 127)", 5, 1);

    drawLine(options, line);

    // Two circle to draw the dial at the base (give its a nice effect?)
    drawNeedleDial(options, 1, "white", "white");
    drawNeedleDial(options, 1, "white", "white");

}

function buildOptionsAsJSON(canvas, iSpeed) {
    /* Setting for the speedometer
    * Alter these to modify its look and feel
    */

    var centerX = 105,
        centerY = 105,
        radius = 75,
        outerRadius = 100;

    // Create a speedometer object using Javascript object notation
    return {
        ctx: canvas.getContext('2d'),
        speed: iSpeed,
        center:    {
            X: centerX,
            Y: centerY
        },
        levelRadius: radius - 10,
        gaugeOptions: {
            center:    {
                X: centerX,
                Y: centerY
            },
            radius: radius
        },
        radius: outerRadius
    };
}

function clearCanvas(options) {
    options.ctx.clearRect(0, 0, 800, 600);
    applyDefaultContextSettings(options);
}

function draw() {
    /* Main entry point for drawing the speedometer
    * If canvas is not support alert the user.
    */
        
    console.log('Target: ' + iTargetSpeed);
    console.log('Current: ' + iCurrentSpeed);
    
    var canvas = document.getElementById('speedometer'),
        options = null;

    // Canvas good?
    if (canvas !== null && canvas.getContext) {
        options = buildOptionsAsJSON(canvas, iCurrentSpeed);

        // Clear canvas
        clearCanvas(options);

        // Draw the metallic styled edge
        drawMetallicArc(options);

        // Draw thw background
        drawBackground(options);

        // Draw tick marks
        drawTicks(options);

        // Draw labels on markers
        drawTextMarkers(options);

        // Draw speeometer colour arc
        drawSpeedometerColourArc(options);

        // Draw the needle and base
        drawNeedle(options);
        
    } else {
        alert("Canvas not supported by your browser!");
    }
    
    if(iTargetSpeed == iCurrentSpeed) {
        clearTimeout(job);
        return;
    } else if(iTargetSpeed < iCurrentSpeed) {
        bDecrement = true;
    } else if(iTargetSpeed > iCurrentSpeed) {
        bDecrement = false;
    }
    
    if(bDecrement) {
        if(iCurrentSpeed - 10 < iTargetSpeed)
            iCurrentSpeed = iCurrentSpeed - 1;
        else
            iCurrentSpeed = iCurrentSpeed - 5;
    } else {
    
        if(iCurrentSpeed + 10 > iTargetSpeed)
            iCurrentSpeed = iCurrentSpeed + 1;
        else
            iCurrentSpeed = iCurrentSpeed + 5;
    }
    
    job = setTimeout("draw()", 5);
}

function drawWithInputValue(txtSpeed) {

    //var txtSpeed = document.getElementById('txtSpeed');

    if (txtSpeed !== null) {

        iTargetSpeed = parseFloat(txtSpeed);

        // Sanity checks
        if (isNaN(iTargetSpeed)) {
            iTargetSpeed = 0;
        } else if (iTargetSpeed < 0) {
            iTargetSpeed = 0;
        } else if (iTargetSpeed > 80) {
            iTargetSpeed = 80;
        }

        job = setTimeout("draw()", 5);
 
    }
}
	$(function () {
		$(".custom-file-input").on("change", function (e) {
			var fileList = {};
			fileList = e.target.files;
			var fileName = '';
			if ($('#ULView').attr('src')) {
				URL.revokeObjectURL($('#ULView').attr('src'));
			} else if ($('#URView').attr('src')) {
				URL.revokeObjectURL($('#URView').attr('src'));
			} else if ($('#DLView').attr('src')) {
				URL.revokeObjectURL($('#DLView').attr('src'));
			} else if ($('#DRView').attr('src')) {
				URL.revokeObjectURL($('#DRView').attr('src'));
			}
			for (i = 0; i < fileList.length; i++) {
				if (fileName == '') {
					fileName = fileList[i].name;
				} else {
					fileName += " , " + fileList[i].name;
				}
				if (i == 0) {
					$('#ULView').attr('src', URL.createObjectURL(fileList[i]));
					console.log(URL.createObjectURL(fileList[i]));
				} else if (i == 1) {
					$('#URView').attr('src', URL.createObjectURL(fileList[i]));
				} else if (i == 2) {
					$('#DLView').attr('src', URL.createObjectURL(fileList[i]));
				} else if (i == 3) {
					$('#DRView').attr('src', URL.createObjectURL(fileList[i]));
				}
			}
			$(this).siblings(".custom-file-label").addClass("selected").html(fileName);
		});
	});


	$('#result').click(function (e) {

		var data = {};
		console.log($('#updImg'));
		data = { 'url': $('#updImg')[0].value };
		//var data = $('#updImg')[0].value;

		console.log(data);
		var originalData = "";
		var fakeData = "";
		$.ajax({
			type: "POST",
			url: "http://localhost:3000/predict",
			//async:false,
			//crossDomain:true,
			data: JSON.stringify(data),
			contentType: "application/json",
			success: function (result) {
				console.log(result);
				for (i = 0; i < result.length; i++) {
					if (result[i].tagName == "Original") {
						originalData = (result[i].probability * 100.0).toFixed(2) + "%";
						console.log("org", originalData);
					}
					if (result[i].tagName == "Fake") {
						fakeData = (result[i].probability * 100.0).toFixed(2) + "%";
						console.log("fak", fakeData);
					}
                }
                if (originalData > fakeData) {
            //alert("into");
            drawWithInputValue(originalData);
			$("#prediction_val").val(originalData);
			$("#prediction_decs").val("Original");
		} else {
            drawWithInputValue(fakeData);
			$("#prediction_val").val(fakeData);
			$("#prediction_decs").val("Fake");
		}
			}
		});

		percent = 0;
		timerId = setInterval(function () {

			// increment progress bar
			percent += 5;
			$('#progress').css('width', percent + '%');

			if (percent >= 100) {
				clearInterval(timerId);
				//$('#btn').attr('disabled', false);
				$('#progress').removeClass('progress-bar-animated active').html('Complete');
			}
		}, 300);
	});

</script>

</html>